use std::fs::File;
use std::io::{self, BufReader, BufWriter, Read, Write};
use std::path::PathBuf;

use anyhow::{Context, Result, anyhow};
use base64::Engine;
use clap::Parser;

#[derive(Parser, Debug)]
#[command(
    name = "program-dump-json",
    about = "Convert program dump binary output to JSON"
)]
struct Args {
    /// Path to the program_transaction_dump.bin file generated by blockzilla
    #[arg(value_name = "INPUT")]
    input: PathBuf,

    /// Optional output path for the JSON file (defaults to stdout)
    #[arg(short, long, value_name = "OUTPUT")]
    output: Option<PathBuf>,

    /// Emit compact JSON instead of pretty-printing
    #[arg(long, default_value_t = false)]
    compact: bool,
}

const PROGRAM_ID_LEN: usize = 32;
const TX_BYTES_MAX: usize = 64 << 20; // 64 MiB, matches wincode len constraint
const TX_COUNT_MAX: usize = 1 << 28; // matches wincode len constraint

fn main() -> Result<()> {
    let args = Args::parse();

    let input = File::open(&args.input)
        .with_context(|| format!("failed to open {}", args.input.display()))?;
    let mut reader = BufReader::with_capacity(256 * 1024, input);

    let programs = read_programs(&mut reader)?;
    let start_slot = read_u64_le(&mut reader)?;
    let end_slot = read_u64_le(&mut reader)?;
    let tx_count = read_bincode_len(&mut reader, TX_COUNT_MAX, "transaction count")?;

    let output: Box<dyn Write> = if let Some(path) = args.output.as_ref() {
        if let Some(parent) = path.parent() {
            if !parent.as_os_str().is_empty() {
                std::fs::create_dir_all(parent)?;
            }
        }
        let file =
            File::create(path).with_context(|| format!("failed to create {}", path.display()))?;
        Box::new(BufWriter::new(file))
    } else {
        Box::new(io::BufWriter::new(io::stdout().lock()))
    };

    if args.compact {
        write_compact_json(
            output,
            programs,
            start_slot,
            end_slot,
            tx_count,
            &mut reader,
        )?;
    } else {
        write_pretty_json(
            output,
            programs,
            start_slot,
            end_slot,
            tx_count,
            &mut reader,
        )?;
    }

    Ok(())
}

fn write_compact_json(
    mut writer: Box<dyn Write>,
    programs: Vec<[u8; PROGRAM_ID_LEN]>,
    start_slot: u64,
    end_slot: u64,
    tx_count: usize,
    reader: &mut BufReader<File>,
) -> Result<()> {
    write!(writer, "{{\"programs\":[")?;
    for (i, program) in programs.iter().enumerate() {
        if i > 0 {
            writer.write_all(b",")?;
        }
        write!(writer, "\"{}\"", bs58::encode(program).into_string())?;
    }

    write!(
        writer,
        "],\"start_slot\":{},\"end_slot\":{},\"transactions\":[",
        start_slot, end_slot
    )?;

    for idx in 0..tx_count {
        if idx > 0 {
            writer.write_all(b",")?;
        }
        write_transaction_object(&mut writer, reader, idx)?;
    }

    writer.write_all(b"]}")?;
    writer.flush()?;

    Ok(())
}

fn write_pretty_json(
    mut writer: Box<dyn Write>,
    programs: Vec<[u8; PROGRAM_ID_LEN]>,
    start_slot: u64,
    end_slot: u64,
    tx_count: usize,
    reader: &mut BufReader<File>,
) -> Result<()> {
    writeln!(writer, "{{")?;
    writeln!(writer, "  \"programs\": [")?;
    for (i, program) in programs.iter().enumerate() {
        let suffix = if i + 1 == programs.len() { "" } else { "," };
        writeln!(
            writer,
            "    \"{}\"{}",
            bs58::encode(program).into_string(),
            suffix
        )?;
    }
    writeln!(writer, "  ],")?;
    writeln!(writer, "  \"start_slot\": {},", start_slot)?;
    writeln!(writer, "  \"end_slot\": {},", end_slot)?;
    writeln!(writer, "  \"transactions\": [")?;

    for idx in 0..tx_count {
        if idx > 0 {
            write!(writer, ",\n")?;
        }
        write!(writer, "    ")?;
        write_transaction_object(&mut writer, reader, idx)?;
    }

    writeln!(writer)?;

    writeln!(writer, "  ]")?;
    writeln!(writer, "}}")?;
    writer.flush()?;

    Ok(())
}

fn write_transaction_object(
    writer: &mut dyn Write,
    reader: &mut BufReader<File>,
    tx_index: usize,
) -> Result<()> {
    let slot = read_u64_le(reader)
        .with_context(|| format!("failed to read slot for transaction {}", tx_index + 1))?;
    let matched_programs = read_matched_programs(reader).with_context(|| {
        format!(
            "failed to read matched programs for transaction {}",
            tx_index + 1
        )
    })?;
    let tx_bytes = read_transaction_bytes(reader).with_context(|| {
        format!(
            "failed to read transaction bytes for slot {slot} (index {})",
            tx_index + 1
        )
    })?;

    write!(writer, "{{\"slot\":{},\"matched_programs\":[", slot)?;
    for (i, program) in matched_programs.iter().enumerate() {
        if i > 0 {
            writer.write_all(b",")?;
        }
        write!(writer, "\"{}\"", bs58::encode(program).into_string())?;
    }
    write!(
        writer,
        "],\"tx_base64\":\"{}\"}}",
        base64::engine::general_purpose::STANDARD.encode(tx_bytes)
    )?;

    Ok(())
}

fn read_programs(reader: &mut BufReader<File>) -> Result<Vec<[u8; PROGRAM_ID_LEN]>> {
    let len = read_short_vec_len(reader)?;
    let mut programs = Vec::with_capacity(len);
    for _ in 0..len {
        let mut buf = [0u8; PROGRAM_ID_LEN];
        reader.read_exact(&mut buf)?;
        programs.push(buf);
    }
    Ok(programs)
}

fn read_matched_programs(reader: &mut BufReader<File>) -> Result<Vec<[u8; PROGRAM_ID_LEN]>> {
    let len = read_short_vec_len(reader)?;
    let mut matched = Vec::with_capacity(len);
    for _ in 0..len {
        let mut buf = [0u8; PROGRAM_ID_LEN];
        reader.read_exact(&mut buf)?;
        matched.push(buf);
    }
    Ok(matched)
}

fn read_short_vec_len(reader: &mut BufReader<File>) -> Result<usize> {
    let mut len = [0u8; 1];
    reader.read_exact(&mut len)?;
    if len[0] & 0x80 == 0 {
        return Ok(len[0] as usize);
    }

    let mut second = [0u8; 1];
    reader.read_exact(&mut second)?;
    let mut value = ((len[0] & 0x7f) as u16) | (((second[0] & 0x7f) as u16) << 7);
    if second[0] & 0x80 == 0 {
        return Ok(value as usize);
    }

    let mut third = [0u8; 1];
    reader.read_exact(&mut third)?;
    value |= (third[0] as u16) << 14;
    Ok(value as usize)
}

fn read_transaction_bytes(reader: &mut BufReader<File>) -> Result<Vec<u8>> {
    let len = read_bincode_len(reader, TX_BYTES_MAX, "transaction length")?;
    let mut buf = vec![0u8; len];
    reader.read_exact(&mut buf)?;
    Ok(buf)
}

fn read_u64_le(reader: &mut BufReader<File>) -> Result<u64> {
    let mut buf = [0u8; 8];
    reader.read_exact(&mut buf)?;
    Ok(u64::from_le_bytes(buf))
}

fn read_bincode_len(reader: &mut BufReader<File>, max: usize, label: &str) -> Result<usize> {
    let mut buf = [0u8; 4];
    reader.read_exact(&mut buf)?;
    let len = u32::from_le_bytes(buf) as usize;
    if len > max {
        return Err(anyhow!("{label} {len} exceeds limit {max}"));
    }
    Ok(len)
}
