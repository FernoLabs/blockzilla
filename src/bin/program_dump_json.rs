use anyhow::{Context, Result};
use base64::Engine;
use clap::Parser;
use serde::Serialize;
use std::path::PathBuf;
use tokio::{fs, io::AsyncWriteExt};
use wincode::SchemaRead;

#[derive(Debug, Clone, SchemaRead)]
struct ProgramTransactionRecord {
    slot: u64,
    #[wincode(with = "wincode::containers::Vec<[u8; 32], wincode::len::short_vec::ShortU16Len>")]
    matched_programs: Vec<[u8; 32]>,
    #[wincode(with = "wincode::containers::Vec<u8, wincode::len::BincodeLen<{ 64 << 20 }>>")]
    tx_bytes: Vec<u8>,
}

#[derive(Debug, Clone, SchemaRead)]
struct ProgramTransactionDump {
    #[wincode(with = "wincode::containers::Vec<[u8; 32], wincode::len::short_vec::ShortU16Len>")]
    programs: Vec<[u8; 32]>,
    start_slot: u64,
    end_slot: u64,
    #[wincode(
        with = "wincode::containers::Vec<ProgramTransactionRecord, wincode::len::BincodeLen<{ 1 << 28 }>>"
    )]
    transactions: Vec<ProgramTransactionRecord>,
}

#[derive(Parser, Debug)]
#[command(
    name = "program-dump-json",
    about = "Convert program dump binary output to JSON"
)]
struct Args {
    /// Path to the program_transaction_dump.bin file generated by blockzilla
    #[arg(value_name = "INPUT")]
    input: PathBuf,

    /// Optional output path for the JSON file (defaults to stdout)
    #[arg(short, long, value_name = "OUTPUT")]
    output: Option<PathBuf>,

    /// Emit compact JSON instead of pretty-printing
    #[arg(long, default_value_t = false)]
    compact: bool,
}

#[derive(Serialize)]
struct JsonTransactionRecord {
    slot: u64,
    matched_programs: Vec<String>,
    tx_base64: String,
}

#[derive(Serialize)]
struct JsonDump {
    programs: Vec<String>,
    start_slot: u64,
    end_slot: u64,
    transactions: Vec<JsonTransactionRecord>,
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();

    let data = fs::read(&args.input)
        .await
        .with_context(|| format!("failed to read {}", args.input.display()))?;
    let dump: ProgramTransactionDump = wincode::deserialize(&data)?;

    let json_dump = JsonDump {
        programs: dump.programs.iter().map(to_base58).collect(),
        start_slot: dump.start_slot,
        end_slot: dump.end_slot,
        transactions: dump
            .transactions
            .into_iter()
            .map(|tx| JsonTransactionRecord {
                slot: tx.slot,
                matched_programs: tx.matched_programs.iter().map(to_base58).collect(),
                tx_base64: base64::engine::general_purpose::STANDARD.encode(tx.tx_bytes),
            })
            .collect(),
    };

    let json = if args.compact {
        serde_json::to_string(&json_dump)?
    } else {
        serde_json::to_string_pretty(&json_dump)?
    };

    if let Some(path) = args.output {
        if let Some(parent) = path.parent() {
            if !parent.as_os_str().is_empty() {
                fs::create_dir_all(parent).await?;
            }
        }
        let mut file = fs::File::create(&path)
            .await
            .with_context(|| format!("failed to create {}", path.display()))?;
        file.write_all(json.as_bytes()).await?;
    } else {
        println!("{}", json);
    }

    Ok(())
}

fn to_base58(bytes: &[u8; 32]) -> String {
    bs58::encode(bytes).into_string()
}
